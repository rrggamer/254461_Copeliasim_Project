# -*- coding: utf-8 -*-
# Cubic polynomial joint-space trajectory (rest-to-rest) with accel limit check
# ????? CoppeliaSim Python script (?? sysCall_* callbacks)

import math
import random
import numpy as np

PI = math.pi
DEG = PI/180.0

# --------- ???????????????????? ---------
# ??? joint ??? UR5 (????????; ????????????? scene ??????)
JOINT_PATHS = [
    "/UR5/joint",
    "/UR5/joint/link/joint",
    "/UR5/joint/link/joint/link/joint",
    "/UR5/joint/link/joint/link/joint/link/joint",
    "/UR5/joint/link/joint/link/joint/link/joint/link/joint",
    "/UR5/joint/link/joint/link/joint/link/joint/link/joint/link/joint",
]

# ??????? (deg) ???????????????????? (?????????? ? ??? UR5)
JOINT_LIMITS_DEG = [
    (-170, 170),   # J1
    (-120, 120),   # J2
    (-170, 170),   # J3
    (-190, 190),   # J4
    (-120, 120),   # J5
    (-360, 360),   # J6
]

# ?????????????????????????????? (rad/s^2)  <-- ???????????????????/?????????
A_MAX = np.array([3.0, 3.0, 3.5, 4.0, 4.0, 5.0], dtype=float)

# ????????????????????? (s)
T_DESIRED = 2.5

# ????????????????? (s)
DT = 0.01
# -----------------------------------------

def rand_joint_vector():
    """????????????/????????????? deg ?????????????? rad"""
    q = []
    for lo, hi in JOINT_LIMITS_DEG:
        q.append(random.uniform(lo, hi)*DEG)
    return np.array(q, dtype=float)

def cubic_time_scaling(T, t):
    """?????? s, sdot, sddot ??? cubic rest-to-rest ? ???? t ? [0,T]"""
    tau = t / T
    s    = 3*tau**2 - 2*tau**3
    sdot = (6.0/T)*tau*(1.0 - tau)        # = 6 t / T^2 - 6 t^2 / T^3
    sdd  = (6.0/(T*T))*(1.0 - 2.0*tau)    # ??????????????????? 6/T^2
    return s, sdot, sdd

def enforce_accel_limit(q0, qf, a_max, T_desired):
    """??? T_desired ???????????????? a_max ?????????? T_eff ??????? cubic"""
    dq = np.abs(qf - q0)
    # T_j >= sqrt(6*|dq|/a_max) ??????????? joint (???? dq=0 ??? T_j=0)
    with np.errstate(divide='ignore', invalid='ignore'):
        Tj = np.sqrt(np.where(a_max>0.0, 6.0*dq/np.maximum(a_max, 1e-12), 0.0))
        Tj[np.isnan(Tj)] = 0.0
    T_eff = max(T_desired, float(np.max(Tj)))
    return T_eff

def plan_cubic_trajectory(q0, qf, a_max, T_desired, dt):
    """????????????? cubic rest-to-rest ??? discrete samples"""
    T = enforce_accel_limit(q0, qf, a_max, T_desired)
    N = max(1, int(math.ceil(T/dt)))
    tgrid = np.linspace(0.0, T, N+1)
    dq = (qf - q0)

    q   = np.zeros((N+1, 6))
    qd  = np.zeros((N+1, 6))
    qdd = np.zeros((N+1, 6))

    for k, t in enumerate(tgrid):
        s, sdot, sdd = cubic_time_scaling(T, t)
        q[k, :]   = q0 + dq * s
        qd[k, :]  = dq * sdot
        qdd[k, :] = dq * sdd

    return tgrid, q, qd, qdd, T

def sysCall_init():
    global sim, joint_h
    sim = require("sim")

    q0 = rand_joint_vector()
    qf = rand_joint_vector()

    # ???????????????
    tgrid, Q, Qd, Qdd, T_eff = plan_cubic_trajectory(q0, qf, A_MAX, T_DESIRED, DT)

    # ??????????? state
    sim.setInt32Signal("traj_length", len(tgrid))
    sim.setFloatSignal("traj_T_eff", T_eff)
    for j in range(6):
        sim.setFloatSignal(f"q0_{j}", float(q0[j]))
        sim.setFloatSignal(f"qf_{j}", float(qf[j]))

    # ??? buffer ?? string signals (????????? persistent data ?????)
    # ???????? bytes ???????? buffer (????????????????????????????? thread ???)
    sim.setInt32Signal("traj_cursor", 0)

    # ?? joint handles
    joint_h = [sim.getObject(path) for path in JOINT_PATHS]

    # ????????????????? position-target (???????????? joint ???? motorized ?? Scene)
    for j in range(6):
        sim.setJointMode(joint_h[j], sim.jointmode_force, 0)
        # ?????? Position control: setJointTargetPosition ????????????

    # ??????????????????? global
    # (???????? list ???????????????)
    global _tgrid, _Q, _Qd, _Qdd
    _tgrid, _Q, _Qd, _Qdd = tgrid, Q, Qd, Qdd

    sim.addLog(sim.verbosity_scriptinfos,
               f"[Cubic] T_desired={T_DESIRED:.3f}s, T_eff={T_eff:.3f}s, steps={len(tgrid)}")


def sysCall_thread():
    global _tgrid, _Q
    n = len(_tgrid)
    for k in range(n):
        qk = _Q[k, :]
        # ???????? joint targets (????????? rad)
        for j in range(6):
            sim.setJointTargetPosition(joint_h[j], float(qk[j]))
        # ???????????????? DT (????? 1 step)
        sim.wait(DT)

    # ?? trajectory: ??????? qf
    for j in range(6):
        sim.setJointTargetPosition(joint_h[j], float(_Q[-1, j]))

    sim.addLog(sim.verbosity_scriptinfos, "[Cubic] Done. Holding final position.")
    # ?????? (?????? loop)
    return
